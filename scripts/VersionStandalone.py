"""Versioning - classes for managing version values in source files"""

# TODO: VERSION_FILE_TEMPLATE
# The version file may vary and is not automatically generated

import sys
import re
import os

VERSION_KEYS = ['VER_MAJOR', 'VER_MINOR', 'VER_PATCH']

BUILD_KEY = 'VER_BUILD'

# The build number file template
BUILD_FILE_TEMPLATE = """/* 
* DO NOT EDIT! Automatically generated by SCons.
*/

enum {
   // This is the build number used on the next release.
   %s = %d
};
"""

VERSION_VALUE_REGEXP = ".*%s\s*=?\s*(\d+)"


class CVersion(object):
    """CVersion class
    
    Parse and increment the version and build numbers in C, C++ source files.
    """

    def __init__(self, version_file, build_file,
                 version_keys = VERSION_KEYS, build_key = BUILD_KEY):
        'Initialize the Versioner object with the version and build files'
        self.version_file = version_file
        self.build_file = build_file
        self.version_keys = version_keys
        self.build_key = build_key
        self.build_file_template = BUILD_FILE_TEMPLATE
        # read, parse version file(s)
        self.get_current_version()

    def get_build_file(self):
        'Returns the file containing the build version'
        return self.build_file
        
    def set_build_template(self, template):
        self.build_file_template = template
    
    def get_current_version(self):
        '''Read and parse the version files to get the current version.
        Returns: the current version structure
        '''
        fp = open(self.version_file, 'r')
        contents = fp.read()
        fp.close()
        
        version = []
        for key in self.version_keys:
            result = re.search(VERSION_VALUE_REGEXP % key, contents, 
                               re.MULTILINE | re.DOTALL)
            if result:
                version += [ int(result.group(1)) ]
            else:
                raise Exception("Error: '%s' is not a valid version file: can not find %s" % (self.version_file, key))
        version += [ self.get_current_build_number() ]
        self.current_version = version
        return version

    def get_version_str(self, delimiter = '.'):
        'Returns: the version as a string'
        return delimiter.join(str(v) for v in self.current_version)
    
    def get_current_build_number(self):
        '''Read the contents of the given build number file and save it
        for later use.
        Returns: build number, -1 on error
        '''
        # TODO: store the build number
        try:
            fp = open(self.build_file, 'r')
            contents = fp.read()
            fp.close()
            result = re.search(VERSION_VALUE_REGEXP % self.build_key, contents, 
                               re.MULTILINE | re.DOTALL)
            if result:
                self.current_build_number = int(result.group(1))
                return self.current_build_number
            else:
                print "Error: '%s' is not a valid build number file: can not find %s" % (self.build_file, self.build_key)
                return -1
            # Note that this is the *current* build number
            # print "Build: %d" % (build_number) # debug
        except Exception, ex:
            print ex
            return -1

    # TODO: set_current_version

    def increment_build_number(self, build_number=None, dry_run=False):
        '''Increment the build number and regenerate the build number
        file. Returns: the new build number, or -1 on error.
        '''
        try:
            if build_number is None:
                # get the *current* build number
                build_number = self.get_current_build_number()
            # Increment and regenerate the build number file.
            build_number += 1
            if not dry_run:
                print "Incrementing %s for the next build" % self.build_file
                fp = open(self.build_file, 'w')
                fp.write(self.build_file_template % (self.build_key, build_number))
                fp.close()
            else:
                print "DRY RUN: incrementing build number to %d in %s" % (build_number, self.build_file)

            return build_number
        except Exception, ex:
            print "Failed to increment the build number"
            print ex
            return -1

        
    # SCons actions
    
    def increment_version_action(self, target, source, env):
        dry_run = env.has_key('dry_run') and int(env['dry_run'])
        bn = self.increment_build_number(dry_run=dry_run)
        if bn < 0:
            # return a non-zero error code
            return 1
        return 0

    # TODO: set_version_action


import imp

PYTHON_VERSION_FILE_TEMPLATE = """#
# The version in this file is automatically updated by the release script.
#
# PLEASE DO NOT CHANGE THE SYNTAX OF THE VERSION VALUE
# 
{version_attr} = ({major}, {minor}, {release}, {build})

# END OF FILE
"""

PYTHON_BUILD_INDEX = 3

class PyVersion(object):
    """PyVersion class

    Parse and increment the version numbers in python source files.
    """
    DEFAULT_VERSION_ATTR = 'VERSION'

    def __init__(self, module_name, version_file, build_file, 
                 version_attr = '', build_key = BUILD_KEY):
        'Initialize the PyVersion object with a module name and the path to the version file'
        self.module_name = module_name
        self.version_file = version_file
        self.build_file = build_file
        self.version_attr = version_attr
        if not self.version_attr:
            self.version_attr = self.DEFAULT_VERSION_ATTR
        self.version_file_template = PYTHON_VERSION_FILE_TEMPLATE
        self.build_key = build_key
        self.build_file_template = BUILD_FILE_TEMPLATE
        # read, parse version file(s)
        self.load_current_version()

    def get_build_file(self):
        'Returns the file containing the build version'
        return self.version_file

    def set_build_template(self, template):
        self.version_file_template = template

    def load_current_version(self):
        '''Read and parse the version files to get the current version.
        Returns: the current version structure
        '''
        self.module = imp.load_source(self.module_name, self.version_file)
        self.current_version = [v for v in getattr(self.module, self.version_attr)]
        return self.current_version
        
        
    def get_version_str(self, delimiter = '.'):
        'Returns: the current version as a string'
        return delimiter.join(str(v) for v in self.current_version)
    
    def get_current_version(self):
        '''Returns: the current version structure
        '''
        return self.current_version

    def get_current_build_number(self):
        return self.current_version[PYTHON_BUILD_INDEX]

    def set_current_version(self, major=None, minor=None, release=None, build=None, 
                            dry_run=False):
        '''Update the version with specific values, write new value to the version file
        '''
        new_version = [
            major   if major   is not None else self.current_version[0],
            minor   if minor   is not None else self.current_version[1],
            release if release is not None else self.current_version[2],
            build   if build   is not None else self.current_version[3],
        ]
        v_out = self.version_file_template.format(version_attr=self.version_attr,
                                                  major=new_version[0],
                                                  minor=new_version[1],
                                                  release=new_version[2],
                                                  build=new_version[3])
        msg = 'Setting version in {0} to {1}'.format(self.version_file,
                                                     new_version)
        if not dry_run:
            vf = open(self.version_file, 'w')
            vf.write(v_out)
            vf.close()
            print msg
        else:
            print 'DRY RUN: ' + msg
        self.current_version = new_version
        
        new_build  = build if build is not None else self.current_version[3]
        msg = 'Setting version in {0} to {1}'.format(self.build_file, new_version[3])
        if not dry_run:
            fp = open(self.build_file, 'w')
            fp.write(self.build_file_template % (BUILD_KEY, new_version[3]))
            fp.close()
            print msg
        else:
            print 'DRY RUN: ' + msg

    def increment_build_number(self, dry_run = False):
        '''Increment the build number and regenerate the version file.
        Returns: next build number, or -1 on error.
        '''
        bnum = self.get_current_build_number() + 1
        try:
            self.set_current_version(build=bnum, dry_run=dry_run)
            return bnum        
        except Exception, ex:
            print "Failed to increment the build number"
            print ex
            return -1
    
    # SCons actions
    
    def increment_version_action(self, target, source, env):
        dry_run = env.has_key('dry_run') and int(env['dry_run'])
        bn = self.increment_build_number(dry_run)
        if bn < 0:
            # return a non-zero error code
            return 1
        return 0

    def set_version_action(self, target, source, env):
        dry_run = env.has_key('dry_run') and int(env['dry_run'])
        envvar = env['VERSION_ENVVAR'] if env.has_key('VERSION_ENVVAR') else 'VERSION'
        version_sep = env['VERSION_SEPARATOR'] if env.has_key('VERSION_SEPARATOR') else '.'
        try:
            new_version = [int(v) for v in os.environ[envvar].split(version_sep)]
            self.set_current_version(major=new_version[0],
                                     minor=new_version[1],
                                     release=new_version[2],
                                     build=new_version[3],
                                     dry_run=dry_run)
            return 0
        except Exception as ex:
            # return a non-zero error code
            print ex
            return 1


def _get_target_name(base_name, prefix = ''):
    target_name = base_name
    if prefix:
        target_name = prefix + '_' + base_name
    return target_name

def _generate_targets(env, version_obj, alias_prefix = ''):
    'Generate the get_version and incr_version targets'
    # Define the (phony) get and increment targets
    dummy_target = _get_target_name('get_version', alias_prefix)
    get_version = env.Command('always.' + dummy_target, [ version_obj.version_file ],
                              '@echo %s' % version_obj.get_version_str())
    env.AlwaysBuild(get_version)
    env.Alias(dummy_target, get_version)

    dummy_target = _get_target_name('incr_version', alias_prefix)
    incr_version = env.Command('always.' + dummy_target, [ version_obj.version_file ],
                               version_obj.increment_version_action)
    env.AlwaysBuild(incr_version)
    env.Alias(dummy_target, incr_version)

    # TODO: always provide set_version


def generate_cversion(env, version_file, build_file, 
                      version_keys = VERSION_KEYS, build_key = BUILD_KEY, 
                      alias_prefix = ''):
    '''Create the Version object in the environment
    Generate the get_version and incr_version targets
    '''
    # add the version object to the environment -- this is not common because
    # of the arguments to CVersion init
    obj_name = alias_prefix
    if not alias_prefix:
        obj_name = '_default_'    
    if not 'Version' in env:
        env['Version'] = {}
    if not env['Version'].has_key(obj_name):
        version_obj = CVersion(version_file, build_file, 
                               version_keys = version_keys, build_key = build_key)
        env['Version'][obj_name] = version_obj

    _generate_targets(env, env['Version'][obj_name], alias_prefix)
    return version_obj

def generate_pyversion(env, module_name, version_file, build_file,
                       version_attr = 'VERSION', alias_prefix = ''):
    '''Create the Version object in the environment
    Generate the get_version, set_version and incr_version targets
    '''
    # add the version object to the environment -- this is not common because
    # of the arguments to PyVersion init
    obj_name = alias_prefix
    if not alias_prefix:
        obj_name = '_default_'    
    if not 'Version' in env:
        env['Version'] = {}
    if not env['Version'].has_key(obj_name):
        env['Version'][obj_name] = PyVersion(module_name, version_file, 
                                             build_file,
                                             version_attr=version_attr)

    version_obj = env['Version'][obj_name]
    _generate_targets(env, version_obj, alias_prefix)
    # for Python, provide set_version target, alias
    dummy_target = _get_target_name('set_version', alias_prefix)
    set_version = env.Command('always.' + dummy_target, [ version_obj.version_file ],
                               version_obj.set_version_action)
    env.AlwaysBuild(set_version)
    env.Alias(dummy_target, set_version)
    return version_obj
